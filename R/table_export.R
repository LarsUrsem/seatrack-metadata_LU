#' Export the flextable to an Excel file with formatting
#'
#' This function exports a flextable object generated by `export_appendix_table_excel` to an Excel file, forcing specific formatting such as column widths, row heights, and text rotation.
#'
#' @param ft A flextable object to be exported
#' @param file_path The file path where the Excel file will be saved
#' @param sheet_name The name of the worksheet in the Excel file (default is "table")
#' @param body_cell_width The width of the body cells (default is 4)
#' @param species_height The height of the species header row (default is 100)
#' @param lme_width The width of the LME column (default is 4)
#' @examples
#' \dontrun{
#' export_appendix_table_excel(ft, "appendix_table.xlsx")
#' }
#' @export
#' @importFrom openxlsx2 wb_workbook wb_set_col_widths wb_set_row_heights int2col
#' @importFrom flexlsx wb_add_flextable
export_appendix_table_excel <- function(ft, file_path, sheet_name = "table", body_cell_width = 4, species_height = 100, lme_width = 4) {
    wb <- openxlsx2::wb_workbook()$add_worksheet(sheet_name)
    wb <- flexlsx::wb_add_flextable(wb, sheet_name, ft)

    lme_range <- paste0("A3:A", nrow(ft$body$content$data) + 3)
    wb$add_cell_style(dims = lme_range, textRotation = 90)
    wb <- openxlsx2::wb_set_col_widths(wb, cols = 1, widths = lme_width)

    species_range <- paste0("C1:", openxlsx2::int2col(ncol(ft$body$content$data)), 1)
    wb$add_cell_style(dims = species_range, textRotation = 90)
    wb <- openxlsx2::wb_set_row_heights(wb, rows = 1, heights = species_height)

    wb <- openxlsx2::wb_set_col_widths(wb, cols = 3:ncol(ft$body$content$data), widths = body_cell_width)

    wb$save(file_path)
}

#' Create a formatted flextable for the appendix table
#'
#' This function generates a flextable summarizing deployment and retrieval data for specified logger types and age classes.
#' It includes background coloring based on success rates and organizes species into groups with distinct colors.
#'
#' @param field_plan_clean Data frame containing the cleaned field plan data
#' @param logger_type Type of logger to filter by (e.g., "GLS", "GPS", "GSM")
#' @param age_target Age class to filter by (e.g., "A" for adult, "C" for chick)
#' @param target_species Vector of species names to include in the table
#' @return A formatted flextable object
#' @examples
#' \dontrun{
#' create_appendix_table(field_plan_clean, "GLS", "A", target_species)
#' }
#' @export
create_appendix_table <- function(field_plan_clean, logger_type, age_target, target_species) {
    # Should move this to a data file at some point
    # Define species groups and their colours
    species_groups <- rbind(
        data.frame(type = "divers", species = c(
            "Atlantic puffin", "Br\u00FCnnich's guillemot", "Common guillemot",
            "Little auk", "Razorbill"
        ), colour = "#99B8E1"),
        data.frame(type = "surface_divers", species = c(
            "Arctic tern", "Black-legged kittiwake", "Great skua",
            "Leach's Storm Petrel", "Northern fulmar", "Northern gannet"
        ), colour = "#C9D9EF"),
        data.frame(
            type = "gull", species = c(
                "Glaucous gull", "Herring gull",
                "Lesser black-backed gull"
            ),
            colour = "#FDECCE"
        ),
        data.frame(type = "shag", species = c("European shag"), colour = "#FCC363"),
        data.frame(type = "eider", species = c("Common eider"), colour = "#F8A482"),
        data.frame(type = "total", species = "Total", colour = "white")
    )


    bg1 <- "#eae4df"
    bg2 <- "#d6c9c2"



    # Function to return background colour based on value of x
    success_col_func <- function(x, background) {
        # Define colour palette
        col_palette <- c("#EF3F27", "#FEC76B", "#F2EF92", "#A3D09C")
        # Check which values in x are numeric
        numeric_x_bool <- !is.na(x)

        # Create a new vector to hold the colours
        new_x <- rep(background, length(x))

        # Only apply colouring to numeric values
        if (sum(numeric_x_bool) > 0) {
            # Cut numeric values into bins and assign colours
            col_cut <- cut(x[numeric_x_bool],
                breaks = c(0, 0.05, 0.25, 0.45, Inf),
                include.lowest = TRUE, label = FALSE, right = FALSE
            )
            # Assign colours based on bins
            new_x[numeric_x_bool] <- col_palette[col_cut]
        }

        return(new_x)
    }

    # Wrap success_col_func with bg1
    success_col_func_deploy <- function(x) {
        return(success_col_func(x, bg1))
    }
    # Wrap success_col_func with bg2
    success_col_func_retrieved <- function(x) {
        return(success_col_func(x, bg2))
    }

    # If Total is not in target_species, add it
    if (!"Total" %in% target_species) {
        target_species <- c(target_species, "Total")
    }

    # Filter field_plan_clean for logger_type and age_target
    field_plan_clean_target <- field_plan_clean[field_plan_clean$logger_type == logger_type & field_plan_clean$age == age_target, ]
    field_plan_clean_target$prev_deployed <- NULL

    # Create wide table with pivot_wider
    wide_table <- tidyr::pivot_wider(field_plan_clean_target,
        names_from = c("Species"),
        values_from = c("planned", "retrieved", "deployed", "ret_success", "dep_success"),
        names_sep = "_._"
    )

    # Get indices of deployed and retrieved columns
    deployed_idx <- grep("deployed", names(wide_table))
    retrieved_idx <- grep("retrieved", names(wide_table))

    # Add total columns
    wide_table$retrieved_._Total <- rowSums(wide_table[, retrieved_idx], na.rm = TRUE)
    wide_table$deployed_._Total <- rowSums(wide_table[, deployed_idx], na.rm = TRUE)
    wide_table$ret_success_._Total <- NA
    wide_table$dep_success_._Total <- NA

    # Get indices of columns matching target_species
    species_indices <- unlist(lapply(target_species, function(species) {
        grep(species, names(wide_table))
    }))

    # Create species_table with only the columns in species_indices
    species_table <- data.frame(wide_table[, species_indices])

    # split col names by _._ and keep second part
    species_table_species <- unlist(lapply(names(species_table), function(x) {
        parts <- strsplit(x, "_._")[[1]]
        return(parts[2])
    }))

    # fuzzy match col_keys_species to target_species
    species_table_species_matched <- unlist(lapply(species_table_species, function(x) {
        match <- agrep(x, target_species, max.distance = 0.2, value = TRUE)
        if (length(match) > 0) {
            return(match[1])
        } else {
            return(x)
        }
    }))

    # Order species_table columns by the order of species in species_groups
    species_order <- order(match(species_table_species_matched, species_groups$species))

    # Reorder species_table columns based on species_order
    species_table <- species_table[, species_order]

    # Add LME and Location columns to species_table
    species_table <- data.frame(LME = wide_table$LME, Location = wide_table$Location, species_table)

    # Get new deployed and retrieved indices after reordering
    deployed_idx <- grep("deployed", names(species_table))
    retrieved_idx <- grep("retrieved", names(species_table))

    dr_idx <- sort(c(deployed_idx, retrieved_idx))
    col_keys <- names(species_table)[dr_idx]
    # All column keys including LME and Location
    all_col_keys <- c("LME", "Location", col_keys)

    # Get unique species names in the corect order
    new_species <- unique(species_table_species_matched[species_order][dr_idx])

    # If a value of new_species is greater than 20 characters, replace only the first space with a line break using regex
    new_species_lb <- new_species
    long_species <- nchar(new_species_lb) > 20
    # replace only the first space with a line break
    new_species_lb[long_species] <- sub(" ", "\n", new_species_lb[long_species], fixed = TRUE)

    # Create r_d_labels list with "R" and "D" for each species in new_species
    r_d_labels <- rep(c("R", "D"), length(new_species))
    r_d_labels <- as.list(r_d_labels)

    # Set names of r_d_labels to col_keys
    names(r_d_labels) <- col_keys

    # Add empty labels for LME and Location
    r_d_labels <- c(list(LME = "", Location = ""), r_d_labels)


    # Indices of deployment and retrieval success columns for background colouring
    dep_success_idx <- sapply(unique(species_table_species[species_order]), function(x) {
        which(grepl(x, names(species_table)) & grepl("dep_success", names(species_table)))
    })
    deployment_idx <- sapply(unique(species_table_species[species_order]), function(x) {
        which(grepl(x, names(species_table)) & grepl("deployed", names(species_table)))
    })
    ret_success_idx <- sapply(unique(species_table_species[species_order]), function(x) {
        which(grepl(x, names(species_table)) & grepl("ret_success", names(species_table)))
    })
    retrieval_idx <- sapply(unique(species_table_species[species_order]), function(x) {
        which(grepl(x, names(species_table)) & grepl("retrieved", names(species_table)))
    })

    # create footer
    footer <- data.frame(col_keys = all_col_keys, values = c("", "Total", colSums(species_table[, sort(c(deployment_idx, retrieval_idx))], na.rm = TRUE)))

    ### Start flextable creation
    ft <- flextable(species_table, col_keys = all_col_keys, use_labels = FALSE)
    ft <- set_footer_df(ft, mapping = footer)
    ft <- theme_box(ft)
    ft <- set_header_labels(ft, values = r_d_labels)

    ### Background colours
    # set bg colours
    # Set background colours for deployment and retrieval success columns based on value
    ft <- bg(ft,
        j = names(species_table)[deployment_idx],
        bg = success_col_func_deploy,
        source = names(species_table)[dep_success_idx],
        part = "body"
    )
    ft <- bg(ft,
        j = names(species_table)[retrieval_idx],
        bg = success_col_func_retrieved,
        source = names(species_table)[ret_success_idx],
        part = "body"
    )
    # Alternating background colours for header row
    ft <- bg(ft,
        j = seq(1, length(all_col_keys), 2),
        part = "header",
        bg = bg1
    )
    ft <- bg(ft,
        j = seq(2, length(all_col_keys), 2),
        part = "header",
        bg = bg2
    )

    ### LME formatting
    # Merge the LME cells and set background colour
    ft <- merge_v(ft, j = ~LME)
    # Rotate label
    ft <- rotate(ft, j = 1, rotation = "btlr", part = "body")
    # Set colours
    ft <- bg(ft, j = 1, bg = "#BDD6D5", part = "body")
    ft <- bg(ft, bg = "#BDD6D5", i = 1, j = 1, part = "footer")
    # Merge the top-left cells and set background colour
    ft <- merge_at(ft, i = 1, j = c(1:2), part = "header")
    ft <- bg(ft, bg = "#69A4A4", i = 1, j = 1, part = "header")

    # Footer formatting
    ft <- bg(ft, bg = "#D2D3D5", j = 2:length(all_col_keys), part = "footer")
    ft <- italic(ft, italic = FALSE, part = "footer")

    ### Column widths
    # Get suggested dimensions of the flextable
    ft_dims <- dim_pretty(ft, part = "all")
    # Get the maximum suggested width and height of the cells
    ft_dims_cells <- lapply(ft_dims, function(x) {
        max(x[c(3:length(x))])
    })



    ### Species header row
    # Add a header row above the existing header with species names spanning two columns each
    ft <- add_header_row(ft, values = c("Location", new_species_lb), colwidths = rep(2, length(new_species) + 1))
    # Merge the top-left cells
    ft <- merge_at(ft, j = c(1:2), i = c(1:2), part = "header")
    # Set background colours for species groups
    ft <- bg(ft, i = 1, j = c(3:length(all_col_keys)), bg = rep(species_groups$colour[match(new_species, species_groups$species)], each = 2), part = "header")
    # Rotate species names
    ft <- rotate(ft, i = 1, j = c(3:length(all_col_keys)), rotation = "btlr", part = "header")

    ### Alignments
    # Everything center
    ft <- align(ft, align = "center", part = "all")
    # Locations left aligned
    ft <- align(ft, align = "left", part = "body", j = 2)
    # Location header label left aligned and at bottom of cell
    ft <- align(ft, align = "left", part = "header", j = 1)
    ft <- valign(ft, valign = "bottom", part = "header", j = 1)

    # Set numeric cell widths based on the maximum width
    ft <- width(ft, width = ft_dims_cells$widths, j = col_keys)
    # Try to force the location column to be wider
    ft <- width(ft, width = ft_dims$widths[2], j = "Location")

    return(ft)
}

#' Read and process the field plan Excel sheet
#'
#' This function reads the specified Excel sheet, cleans the data by removing rows with missing values in key columns,
#' converts certain columns to numeric, removes bracketed text from colony names, and combines duplicate locations/species.
#'
#' @param field_plan_path The file path to the field plan Excel sheet
#' @return A data frame containing the processed field plan data
#' @examples
#' \dontrun{
#' get_field_plan("path/to/fieldplan.xlsx")
#' }
#' @export
get_field_plan <- function(field_plan_path) {
    field_plan_sheet <- read_excel(field_plan_path, sheet = "Main", na = c("", "?"))
    field_plan_sheet <- field_plan_sheet[!is.na(field_plan_sheet$Colony) & !is.na(field_plan_sheet$`Ocean area`), ]

    # Force some columns to be numeric
    suppressWarnings({
        field_plan_sheet$`GLS deployments` <- as.numeric(field_plan_sheet$`GLS deployments`)
        field_plan_sheet$`GLS retrievals` <- as.numeric(field_plan_sheet$`GLS retrievals`)
    })

    # remove any strings in brackets from the colony name e.g "\u00C5gotnes (instead of LyngÃ¸y)"" becomes "\u00C5gotnes"
    field_plan_sheet$Colony <- gsub(" \\(.*\\)", "", field_plan_sheet$Colony)

    # Combine duplicate locations/species e.g. Herring gulls instrumented at two sites in Nord-Troms, and assigned two rows in the planning sheet get combined into one.
    field_plan_sheet <- field_plan_combine_locations(field_plan_sheet)

    return(field_plan_sheet)
}

#' Combine duplicate locations/species in the field plan sheet
#'
#' This function aggregates locations with the same colony name, species and age together by summing all numeric variables.
#'
#' @param field_plan_sheet A data frame containing the field plan data
#' @return A data frame with combined locations/species
#' @examples
#' \dontrun{
#' field_plan_combine_locations(field_plan_sheet)
#' }
#' @export
field_plan_combine_locations <- function(field_plan_sheet) {
    # Aggregate locations with the same colony name, species and age together (sum all numeric variables)
    colony_species <- group_by(field_plan_sheet, Colony, Species, Age)
    colony_species_summary <- summarise(colony_species, across(
        where(is.numeric),
        function(x) {
            sum(x, na.rm = TRUE)
        }
    ), .groups = "drop")
    new_field_plan_sheet <- left_join(colony_species_summary, field_plan_sheet, suffix = c("", "._x_"), by = c("Colony", "Species", "Age"), multiple = "first")
    new_field_plan_sheet <- select(new_field_plan_sheet, -ends_with("._x_"))
    new_field_plan_sheet <- new_field_plan_sheet[, names(field_plan_sheet)]
    return(new_field_plan_sheet)
}

#' Check and update locations in the field plan sheet
#'
#' This function checks the locations in the field plan sheet against the SEATRACK database table of colonies, updates the sheet with new locations if provided,
#' calculates the distance of each ocean area from Trondheim, and orders the ocean areas by latitude and distance from Trondheim.
#' @param field_plan_sheet A data frame containing the field plan data
#' @param new_locations An optional data frame containing new locations with columns 'colony' and 'lat'
#' @return A data frame with updated and ordered locations
#' @examples
#' \dontrun{
#' seatrackR::connectSeatrack()
#' field_plan_sheet <- get_field_plan("path/to/fieldplan.xlsx")
#' new_locations <- data.frame(colony = c("Nord-Troms", "\u00C5gotnes"), lat = c(70, 60.40))
#' field_plan_check_locations(field_plan_sheet, new_locations)
#' }
#' @export
field_plan_check_locations <- function(field_plan_sheet, new_locations = NULL) {
    # Check if there is a seatrack DB data connection
    seatrackR:::checkCon()

    # Get all the colonies, load the geometries
    # Should declare con as a global variable to avoid R CMD check note
    all_colonies <- DBI::dbReadTable(con, DBI::Id(
        schema = "metadata",
        table = "colony"
    ))


    all_colonies$geom <- NULL

    field_plan_sheet <- left_join(field_plan_sheet, all_colonies, by = join_by("Colony" == "colony_int_name"))

    # Update the sheet with new locations
    if (!is.null(new_locations) && nrow(new_locations) > 0) {
        for (i in seq_len(nrow(new_locations))) {
            new_data <- new_locations[i, ]
            field_plan_sheet$lat[field_plan_sheet$Colony == new_data$colony] <- new_data$lat
        }
    }

    field_plan_sheet <- field_plan_sheet[!is.na(field_plan_sheet$lat), ]

    # calculate distance of each ocean area from Trondheim (the center of the world)
    field_plan_sheet_ocean <- sf::st_as_sf(field_plan_sheet[!is.na(field_plan_sheet$lon), ], coords = c("lat", "lon"), remove = FALSE, crs = 4326)

    trondheim_coord <- sf::st_sfc(sf::st_point(c(10.3951, 63.4305)), crs = 4326)
    field_plan_sheet_ocean$distance_from_trondheim <- sapply(seq_len(nrow(field_plan_sheet_ocean)), function(i) {
        sf::st_distance(trondheim_coord, field_plan_sheet_ocean[i, ], by_element = TRUE)
    })

    # Get average latitude and longitude of each ocean area
    ocean_area_coords <- group_by(field_plan_sheet_ocean, `Ocean area`)
    ocean_area_coords <- slice_min(ocean_area_coords, order_by = distance_from_trondheim)
    ocean_area_coords <- summarise(ocean_area_coords,
        lat = mean(lat),
        lon = mean(lon),
        distance_from_trondheim = mean(distance_from_trondheim),
        .groups = "drop"
    )

    # Order the ocean areas by distance latitude and distance from Trondheim
    ocean_area_coords <- arrange(ocean_area_coords, desc(lat), distance_from_trondheim)

    field_plan_sheet$`Ocean area` <- factor(field_plan_sheet$`Ocean area`, levels = ocean_area_coords$`Ocean area`)

    field_plan_sheet <- arrange(field_plan_sheet, `Ocean area`, desc(lat))

    return(field_plan_sheet)
}

get_logger_info <- function(species, projects, retrieval_years, deployment_years) {
    # seatrackRdb
    # Check if there is a seatrack DB data connection

    seatrackR:::checkCon()

    logger_info <- seatrackR::getLoggerInfo()
    logger_info <- logger_info[logger_info$deployment_species %in% species & logger_info$project %in% projects, ]
    logger_info <- logger_info[!is.na(logger_info$deployment_data) & !is.na(logger_info$retrieval_date)]
    logger_info <- logger_info[logger_info$download_type %in% c("Successfully downloaded", "Reconstructed")]
    logger_info$deployment_year <- format(logger_info$retrieval_date, "%Y")
    logger_info$retrieval_year <- format(logger_info$retrieval_date, "%Y")


    logger_info_by_retrieval_year <- arrange(logger_info, "retrieval_year")

    retrievals_per_year <- summarise(logger_info[logger_info$retrieval_year %in% retrieval_years, ], n_retrievals = n(), by = "retrieval_year")

    deployments_per_year <- summarise(logger_info[logger_info$deployment_year %in% deployment_years, ], n_deployments = n(), by = "deployment_year")
}

#' Read and clean the field plan data
#'
#' This function processes the field plan data by selecting relevant columns, renaming them, calculating deployment and retrieval success rates,
#' and merging with historical data to compute previous deployments. A connection to the SEATRACK database is required to calculate retrieval success.
#' @param field_plan_sheet A data frame containing the raw field plan data
#' @return A cleaned data frame with deployment and retrieval statistics
#' @examples
#' \dontrun{
#' field_plan_sheet <- get_field_plan("path/to/fieldplan.xlsx")
#' seatrackR::connectSeatrack()
#' field_plan_clean <- get_clean_field_plan(field_plan_sheet)
#' }
#' @export
get_clean_field_plan <- function(field_plan_sheet) {
    field_plan_clean <- field_plan_sheet[, c(
        "Ocean area", "Colony", "Species",
        "GLS assigned", "GLS deployments", "GLS retrievals",
        "GPS assigned", "GPS deployments", "GPS retrievals",
        "GPS-GSM assigned", "GPS-GSM deployments",
        "Age"
    )]
    names(field_plan_clean) <- c(
        "LME", "Location", "Species",
        "planned", "deployed", "retrieved",
        "gps_planned", "gps_deployed", "gps_retrieved",
        "gps_gsm_planned", "gps_gsm_deployed",
        "age"
    )

    field_plan_clean_gps_only <- field_plan_clean[, c(
        "LME", "Location", "Species",
        "gps_planned", "gps_deployed", "gps_retrieved",
        "age"
    )]
    names(field_plan_clean_gps_only) <- c(
        "LME", "Location", "Species",
        "planned", "deployed", "retrieved",
        "age"
    )
    field_plan_clean_gps_only$logger_type <- "GPS"

    field_plan_clean_gsm_only <- field_plan_clean[, c(
        "LME", "Location", "Species",
        "gps_gsm_planned", "gps_gsm_deployed",
        "age"
    )]
    names(field_plan_clean_gsm_only) <- c(
        "LME", "Location", "Species",
        "planned", "deployed",
        "age"
    )
    field_plan_clean_gsm_only$retrieved <- NA
    field_plan_clean_gsm_only$logger_type <- "GSM"
    field_plan_clean_gsm_only <- field_plan_clean_gsm_only[, names(field_plan_clean_gps_only)]


    field_plan_clean[, c("gps_planned", "gps_deployed", "gps_retrieved", "gps_gsm_planned", "gps_gsm_deployed", "gps_gsm_retrieved")] <- NULL
    field_plan_clean$logger_type <- "GLS"
    field_plan_clean <- rbind(field_plan_clean, field_plan_clean_gps_only, field_plan_clean_gsm_only)


    # Deployment success
    field_plan_clean$dep_success <- field_plan_clean$deployed / field_plan_clean$planned

    field_plan_clean$dep_success[is.infinite(field_plan_clean$dep_success)] <- NA

    # Retrieval success
    target_year <- as.numeric(format(Sys.Date(), "%Y")) - 1
    history_table <- get_history_table(target_year, "Retrieval")


    history_table_groups <- group_by(history_table, colony, deployment_species, age, logger_type)
    history_table_summary <- summarise(history_table_groups, prev_deployed = n(), .groups = "drop")

    field_plan_clean <- left_join(field_plan_clean, history_table_summary, by = join_by(
        Location == colony,
        Species == deployment_species,
        age == age,
        logger_type == logger_type
    ))

    field_plan_clean$ret_success <- field_plan_clean$retrieved / field_plan_clean$prev_deployed
    field_plan_clean$ret_success[is.infinite(field_plan_clean$ret_success)] <- NA

    # reorder to match other tables
    field_plan_clean <- field_plan_clean[, c("LME", "Location", "Species", "age", "logger_type", "planned", "retrieved", "deployed", "prev_deployed", "ret_success", "dep_success")]

    return(field_plan_clean)
}


#' Get historical deployment and retrieval data
#'
#' This function retrieves historical deployment and retrieval data from the SEATRACK database for a specified year and event type (Deployment or Retrieval).
#' It filters the data based on the event type, age class, and logger type, and returns a data frame with relevant information.
#' A connection to the SEATRACK database is required.
#' @param history_year The year for which to retrieve historical data (e.g., 2023)
#' @param event_type A vector specifying the event type(s) to filter by (defaults to c("Deployment", "Retrieval"))
#' @return A data frame containing historical deployment and retrieval data
#' @examples
#' \dontrun{
#' seatrackR::connectSeatrack()
#' history_data <- get_history_table(2023, c("Deployment", "Retrieval"))
#' }
#' @export
get_history_table <- function(history_year, event_type = c("Deployment", "Retrieval")) {
    seatrackR:::checkCon()

    # Get all individuals (seems fast, but a tad wasteful in terms of memory)
    individual_info <- seatrackR::getIndividInfo()
    individual_info <- individual_info[!is.na(individual_info$eventType), ]

    # Filter to desired event type and age class.
    individual_events <- individual_info[individual_info$eventType %in% event_type, ]


    logger_info <- seatrackR::getLoggerInfo()
    logger_history <- logger_info[logger_info$session_id %in% individual_events$session_id, ]
    logger_history <- logger_history[!is.na(logger_history$deployment_date), ]

    logger_history$year <- format(logger_history$deployment_date, "%Y")
    logger_history_year <- logger_history[logger_history$year == history_year, ]

    # Try to translate between the age classes
    logger_history_year <- left_join(logger_history_year, individual_info[, c("session_id", "status_age")], by = "session_id")
    logger_history_year <- logger_history_year[!is.na(logger_history_year$status_age), ]
    logger_history_year$age <- "A"
    logger_history_year$age[logger_history_year$status_age %in% c("pullus", "juvenile", "chick")] <- "C"

    # Add type of logger
    logger_history_year$logger_type <- "GLS"

    # These need to be accurate at some point, and probably somewhere global
    gps_models <- c("W30A9-SEA-NOT")
    gsm_models <- c("OrniTrack15")

    logger_history_year$logger_type[logger_history_year$logger_model %in% gps_models] <- "GPS"
    logger_history_year$logger_type[logger_history_year$logger_model %in% gsm_models] <- "GPS-GSM"

    return(logger_history_year)
}

# Not used at the moment
# get_logger_tables <- function(field_plan_clean, species) {
#     val_cols <- c("deployed", "planned", "retrieved", "dep_success", "ret_success")
#     all_tables <- lapply(val_cols, function(val_col) {
#         get_logger_table(field_plan_clean, val_col, species)
#     })
#     names(all_tables) <- val_cols
#     return(all_tables)
# }

# # tidyr
# get_logger_table <- function(field_plan_clean, val_col, species) {
#     logger_table <- tidryr::pivot_wider(field_plan_clean,
#         names_from = c(Species),
#         values_from = val_col
#     )
#     logger_table_species <- logger_table[, c(c("LME", "Location", "logger_type", "age"), species)]

#     return(logger_table_species)
# }
